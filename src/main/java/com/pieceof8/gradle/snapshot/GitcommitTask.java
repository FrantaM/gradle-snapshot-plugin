// vi: set softtabstop=4 shiftwidth=4 expandtab:
package com.pieceof8.gradle.snapshot;

import static java.lang.String.format;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Properties;

import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
import org.gradle.api.DefaultTask;
import org.gradle.api.Project;
import org.gradle.api.logging.Logger;
import org.gradle.api.tasks.OutputFile;
import org.gradle.api.tasks.TaskAction;

import lombok.*;

/**
 * A task to extract build information from a Git repository and generate a
 * file with this metadata.
 */
class GitcommitTask extends DefaultTask {

    /** An output label for the properties file. */
    private static final String BUILD_LABEL =
            "Generated by the Gradle Snapshot plugin";

    /** Defines the fallback commit abbrev length if a gitconfig isn't found. */
    private static final int DEFAULT_COMMIT_ABBREV_LENGTH = 7;

    /** The property keys for the build information. */
    static final String BUILD_TIME = "build.time";
    static final String BUILD_AUTHOR_NAME = "build.user.name";
    static final String BUILD_AUTHOR_EMAIL = "build.user.email";

    /** The property keys for the Git commit information. */
    static final String BRANCH = "branch";
    static final String COMMIT_ID = "commit.id";
    static final String COMMIT_ID_ABBREV = "commit.id.abbrev";
    static final String COMMIT_TIME = "commit.time";
    static final String COMMIT_AUTHOR_NAME = "commit.user.name";
    static final String COMMIT_AUTHOR_EMAIL = "commit.user.email";
    static final String COMMIT_MESSAGE_FULL = "commit.message.full";
    static final String COMMIT_MESSAGE_SHORT = "commit.message.short";

    /** The Gradle build system's output logger. */
    private static @NonNull Logger log;

    /** The configuration object for this task. */
    private final @NonNull SnapshotPluginExtension extension;

    /** The properties to store build information collected from Git. */
    @OutputFile @Getter
    private final @NonNull File output;

    /**
     * Initialises the task with default values, obtained from the extension
     * object.
     *
     * @see com.bouncelms.gradle.gitcommit.GitcommitPluginExtension
     */
    public GitcommitTask() {
        final Project project = getProject();
        File outputDir = new File(project.getBuildDir(), "snapshot");
        outputDir.mkdirs();

        extension = project.getExtensions()
                .getByType(SnapshotPluginExtension.class);
        output = new File(outputDir, extension.getSnapshotPropertiesFilename());
        log = project.getLogger();
    }

    /**
     * The main action for this task. The task generates build information in a
     * file from the Git repository and stores it to
     * {@code Project#getBuildDir() "/git/"}. If the Java plugin is enabled on
     * the project this file is added to the generated jar package.
     */
    @TaskAction
    @SneakyThrows(IOException.class)
    public void action() {
        final Project project = getProject();
        File gitDir = locateGitDir(project.getProjectDir());

        Properties props = loadBuildInfo(gitDir);
        props.store(new FileWriter(output), BUILD_LABEL);
    }

    /**
     * Recursively walks up the directory tree starting from
     * {@code Project#getProjectDir()} looking for the {@code Constants#DOT_GIT}
     * if one cannot be found an exception is thrown. This code mirrors the
     * lookup strategy used by the Git command line tool.
     *
     * @param baseDir The base directory of the Gradle project.
     * @return The {@code File} that represents a valid Git directory.
     * @throws FileNotFoundException If the Git directory could not be found.
     */
    @SneakyThrows(FileNotFoundException.class)
    private static File locateGitDir(@NonNull File baseDir) {
        final String dotGit = Constants.DOT_GIT;

        File gitDir;
        while (!(gitDir = new File(baseDir, dotGit)).exists()) {
            log.info("Searching '{}' for a '{}' directory.", baseDir, dotGit);
            baseDir = baseDir.getParentFile();
            if (baseDir == null) {
                val msg = format("Could not locate a '%s' directory. %s",
                        dotGit, "Run Gradle with '--info' for more debugging.");
                throw new FileNotFoundException(msg);
            }
        }
        return gitDir;
    }

    /**
     * Analyses the {@code gitDir} collecting build information from the Git
     * repository.
     *
     * @see java.util.Properties
     * @param gitDir The location of the {@code Constants#DOT_GIT} directory.
     * @return A {@code Properties} file containing the build metadata from the
     * Git repository.
     */
    @SneakyThrows(IOException.class)
    private Properties loadBuildInfo(final @NonNull File gitDir) {
        final Properties props = new Properties();

        FileRepositoryBuilder builder = new FileRepositoryBuilder();
        Repository repo = builder.setGitDir(gitDir)
                .readEnvironment()
                .findGitDir()
                .build();
        StoredConfig conf = repo.getConfig();

        int abbrev = DEFAULT_COMMIT_ABBREV_LENGTH;
        if (conf != null) {
            abbrev = conf.getInt("core", "abbrev", abbrev);
        }

        val sdf = new SimpleDateFormat(extension.getDateFormat());
        put(props, BUILD_TIME, sdf.format(new Date()));

        val userName = conf.getString("user", null, "name");
        put(props, BUILD_AUTHOR_NAME, userName);

        val userEmail = conf.getString("user", null, "email");
        put(props, BUILD_AUTHOR_EMAIL, userEmail);

        val HEAD = repo.getRef(Constants.HEAD);
        if (HEAD == null) {
            val msg = "Could not get HEAD Ref, the repository may be corrupt.";
            throw new RuntimeException(msg);
        }

        RevWalk revWalk = new RevWalk(repo);
        RevCommit commit = revWalk.parseCommit(HEAD.getObjectId());
        revWalk.markStart(commit);

        try {
            put(props, BRANCH, repo.getBranch());

            val commitId = commit.getName();
            put(props, COMMIT_ID, commitId);
            put(props, COMMIT_ID_ABBREV, commitId.substring(0, abbrev));

            val ident = commit.getAuthorIdent();
            put(props, COMMIT_AUTHOR_NAME, ident.getName());
            put(props, COMMIT_AUTHOR_EMAIL, ident.getEmailAddress());

            put(props, COMMIT_MESSAGE_SHORT, commit.getShortMessage().trim());
            put(props, COMMIT_MESSAGE_FULL, commit.getFullMessage().trim());

            // git commit time in sec and java datetime is in ms
            val date = new Date(commit.getCommitTime() * 1000L);
            put(props, COMMIT_TIME, sdf.format(date));
        } finally {
            revWalk.dispose();
        }

        return props;
    }

    /**
     * Adds the key-value pair to the {@code props} file. Each property pair is
     * prefixed with "git." e.g. "git.build.time".
     *
     * @param key The key for the property record.
     * @param value The value of the property record.
     */
    private void put(final @NonNull Properties props, final @NonNull String key,
            final @NonNull String value) {
        if (extension.isVerbose()) {
            log.info("Storing pair: {}={}", key, value);
        }
        props.put("snapshot." + key, value);
    }

}
